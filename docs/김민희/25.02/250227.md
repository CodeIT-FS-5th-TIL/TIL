이 날 어지럼증이 지속돼서 스프린트를 결석했다. 몸이 좀 괜찮아지고 나서 AI랑 같이 React Query를 공부했다.


# React Query 핵심 개념

- ReactQuery는 React 애플리케이션에서 서버 상태 관리를 위한 라이브러리이다.

	**[참고] 서버 상태 vs 클라이언트 상태**

		- 서버 상태
			- 서버에 있는 데이터 (게시글, 유저 정보 등)
			- 여러 사용자가 공유
			- 비동기로 가져와야 함
			- 시간이 지나면 outdated 될 수 있음
		- 클라이언트 상태
			- 브라우저에만 있는 데이터 (모달 열림/닫힘, 입력 값 등)
			- 해당 사용자만 사용
			- 동기적으로 바로 접근 가능
			- UI 상태 관리
- React Query는 서버 상태를 관리하면서 아래의 일들을 자동으로 해준다.
	- 캐싱
	- 데이터 동기화
	- 에러 핸들링
	- 로딩 상태 관리

## 1. queryKey - 데이터 식별자

- React Query가 데이터를 구분하는 고유한 키
- 다른 queryKey ⇒ 다른 데이터로 취급

```javascript
// 각각 다른 데이터로 취급
['posts']                              // 전체 게시글
['posts', { sort: 'recent' }]          // 최신순 게시글
['posts', { sort: 'likes' }]           // 인기순 게시글
['posts', { keyword: 'react' }]        // 검색된 게시글
```


## 2. 데이터 신선도 관리


queryKey별로 신선도를 관리한다.

- 다른 queryKey일 경우 무조건 새로운 데이터를 요청하고, 각각 별도의 캐시로 관리

### staleTime(신선도 시간)


데이터가 “신선(fresh)”하다고 간주되는 시간. 이 시간 동안은 데이터 재요청을 하지 않는다.


```javascript
{
  staleTime: 1000 * 60, // 1분간 신선한 상태 유지
}
```

- **동작 예시**(staleTime: 1분으로 설정)
	- 최초 데이터 요청 → 데이터 받음 →
		- 0~1분: "신선한 상태" ⇒ 재요청 없음
		- 1분 이후: "신선하지 않은 상태" ⇒ 조건 만족 시 재요청
	- “조건 만족”이란 다음 중 하나의 상황일 때를 말한다.
		- 컴포넌트 재마운트
		- 윈도우 포커스
		- 네트워크 재연결
		- 수동 리패치

### cacheTime(캐시 유지 기간)


데이터가 캐시에 남아있는 시간. 이 시간 동안 데이터를 메모리에 보관하여 재사용이 가능하다.

- staleTime ≤ cacheTime 이어야 함

```javascript
{
  cacheTime: 1000 * 60 * 5, // 5분간 캐시 유지
}
```

- **동작 예시**(cacheTime: 5분으로 설정)
	- 최초 데이터 요청 → 데이터 받음 →
		- 0~5분: 캐시 유지 ⇒ 재사용 가능
		- 5분 이후: 캐시 삭제 ⇒ 새로 요청 필요

## 3. 데이터 상태


```javascript
const { 
  data,       // 실제 데이터
  isLoading,  // 첫 로딩 여부(캐시가 없는 데이터에서의 첫 데이터 요청)
  isFetching, // 데이터 요청 중 여부(캐시 유무와 관계 없이 모든 데이터 요청 중 상태. 즉, 백그라운드 업데이트 포함)
  isStale,    // 신선하지 않은 상태 여부
  error       // 에러 정보
} = useQuery(...)
```


## 4. 캐시 동작 방식


### 캐시 있는 경우(cacheTime 이내)

1. 캐시 데이터 즉시 표시
2. 필요시 백그라운드에서 새로운 데이터 요청(staleTime 지남 + 재요청 조건 만족)
3. 새 데이터로 자동 업데이트
- **만약 신선하지 않은데(staleTime 초과) 캐시가 남아있는 경우**
	- staleTime: 1분 / cacheTime: 5분
		1. 최초 데이터 요청 (00:00): 데이터 수신
		2. 1분 후 재방문 (00:01)
			1. 캐시데이터 즉시 표시
			2. 백그라운드 데이터 요청(새로운 데이터 요청)
			3. UI 자동 업데이트(새 데이터로 업데이트)
	- 이런 방식으로 아래의 이점을 달성할 수 있다.
		- 빠른 화면 표시 (캐시)
		- 최신 데이터 유지 (백그라운드 갱신)
		- 부드러운 UX (자연스러운 업데이트)

### 캐시 없는 경우

1. 로딩 상태 표시
2. 새로운 데이터 요청
3. 데이터 표시

## 5. 성능 최적화 전략

- 적절한 staleTime 설정

	staleTime이 너무 길면 데이터가 오래됨, cacheTime이 너무 길면 메모리 사용량 증가


		⇒ 데이터 성격에 맞게 적절히 설정 필요

		- 자주 변경되는 데이터: 짧은 staleTime
		- 정적인 데이터: 긴 staleTime
- 캐시 활용
	- prefetchQuery로 미리 데이터 준비
	- keepPreviousDate로 부드러운 전환
- 로딩 UX 개선
	- 스켈레톤 UI 사용
	- 점진적 로딩 구현

[참고] 데이터 신선도 관리와 캐시 동작 방식은 렌더링 방식과 별개로 독립적으로 동작한다. 신선도와 캐시 상태에 따라 데이터 업데이트 필요할 때, 그 때 렌더링 방식에 따라 다른 방식으로 렌더링이 된다.

