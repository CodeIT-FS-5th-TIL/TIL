## useState와 useEffect

React에서 라이프사이클(컴포넌트가 태어나고 죽는다)에 관여하는 함수를 훅(Hook)이라고 합니다.
useState와 useEffect는 상당히 자주, 지금까지 작성해본 거의 모든 코드에서 사용되고 있지만 사용할 때마다 헷갈려서 챗GPT의 도움을 받았기 때문에 이번에 확실히 정리하여 사용하고자 합니다.

## Hook
Hook은 그냥 JavaScript 함수이지만, 두 가지 규칙을 준수해야 합니다.
- **최상위(at the top level)**에서만 Hook을 호출해야 합니다. 반복문, 조건문, 중첩된 함수 내에서 Hook을 실행하지 마세요.
- **React 함수 컴포넌트** 내에서만 Hook을 호출해야 합니다. 일반 JavaScript 함수에서는 Hook을 호출해서는 안 됩니다.

### useState

- `import { useState } from "react";` 를 통해 import 해와야지 사용할 수 있습니다.
- 컴포넌트에서 상태를 선언하고 관리할 때 사용
- `useState(초기값)` 이와 같은 구조로 사용하여 초기값을 관리

```
import { useState } from "react";

function Example() {
  const [count, setCount] = useState(0); // 초기값을 0으로 설정

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1 증가</button>
    </div>
  );
}
```

-위와 같은 코드 사용 예시를 설명하자면,
  - useState(초기값) → [현재 상태, 상태 변경 함수]를 반환
  - setCount(새로운 값)을 호출하면 컴포넌트가 다시 렌더링됨
  - 상태가 변경될 때마다 해당 컴포넌트가 리렌더링됨

### useEffect

- `import { useEffect } from "react";` 를 통해 import 해와야지 사용할 수 있습니다.
- 컴포넌트가 렌더링될 때 실행해야 하는 부수 효과(side effects)를 처리
- `useEffect(() => { 실행할 코드 }, [의존성 배열])` 이와 같은 구조로 사용하여 의존성 배열의 값이 변경될 때마다 useEffect 실행
- 의존성 배열이 []이면 처음 렌더링되는 시점에 한 번만 실행됨

```
useEffect(() => {
  console.log("컴포넌트가 마운트됨!");
}, []); // 빈 배열 -> 컴포넌트가 처음 렌더링될 때 한 번 실행됨
```

```
useEffect(() => {
  console.log(`count 값이 변경됨: ${count}`);
}, [count]); // count 값이 변경될 때만 실행됨
```

### 📝 정리
- useState
  - 컴포넌트 내부에서 상태를 관리할 때 사용
  - 상태가 변경되면 리렌더링 발생

- useEffect
  - 의존성 배열을 설정하여 실행 시점을 제어 가능

<hr style="border: solid 1px;" />

💬 정리하면서 그동안 어떻게 사용했었는지 되돌아 볼 수 있었다. 이걸로 앞으로 useState와 useEffect를 한결 수월하게 사용할 수 있을 것 같다!